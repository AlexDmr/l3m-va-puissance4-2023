{"userMail":"alexandre.demeure@univ-grenoble-alpes.fr","version":63,"mutants":[{"op":"isValid","comment":"no 2 winners","code":"function anonymous(state\n) {\n\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    return { valid: true };\n\n}","body":"\n\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"errors in reverse priority order","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0], [1, -1], [1, 1], [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0], [1, -1], [1, 1], [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"too much tokens <-> not turn of Pi","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0], [1, -1], [1, 1], [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 >= nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 >= nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0], [1, -1], [1, 1], [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 >= nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 >= nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"missing direction [1, -1]","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        // [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        // [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"Missing direction [1, 0]","code":"function anonymous(state\n) {\n\n    const directions = [\n        // [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        // [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"Mising direction [1, 1]","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        // [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        // [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"Missing direction [0, 1]","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        // [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        // [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"winnercond >=4    --->   >4","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb > 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb > 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"winnercond >= 3","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 3;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 3;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"bad column number (-1)","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c - 1} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c - 1} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"nbP1 > nbP2 /*+ 1*/","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 /*+ 1*/)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 /*+ 1*/)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"nbP2 > nbP1 + 1","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1 + 1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1 + 1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"col >= 6","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length >= 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length >= 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"nbP1 <-> nbP2","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP2 = nb(state, \"P1\");\n    const nbP1 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length >= 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP2 = nb(state, \"P1\");\n    const nbP1 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length >= 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"winner","comment":"nb > 4","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb > 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb > 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"Missing [1, 0]","code":"function anonymous(state\n) {\n\n    const directions = [\n        // [1, 0], \n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        // [1, 0], \n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"Missing  [1, -1]","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        // [1, -1], \n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        // [1, -1], \n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"Missing  [1, 1], ","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        // [1, 1], \n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        // [1, 1], \n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"Missing  [0, 1]","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        // [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        // [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"<= 6 ? \"DRAW\"","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length <= 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length <= 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"L.length === 6 ? \"DRAW\" ","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length === 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length === 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"play","comment":"COL.length > 6","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (COL === undefined) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length > 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (COL === undefined) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length > 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"column à virgule","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 1 || column > 7) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 1 || column > 7) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"column < 0 || column > 6 || !Number.isInteger(column)","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 0 || column > 6 || !Number.isInteger(column)) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 0 || column > 6 || !Number.isInteger(column)) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"column < 1 || column > 6 || !Number.isInteger(column) ","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 1 || column > 6 || !Number.isInteger(column)) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 1 || column > 6 || !Number.isInteger(column)) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"always P1","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"always P2","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: \"P2\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: \"P2\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"no turn change","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn,\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn,\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"wrong token","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.state.turn === \"P1\" ? \"P2\" : \"P1\"])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.state.turn === \"P1\" ? \"P2\" : \"P1\"])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"wrong column","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== (c + 1) ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== (c + 1) ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]}],"suites":[{"id":"CLtMNpXwwUuXorvRyWtK","LtestIds":["9zz2MWHIDHnricejPYEG","zahqfNcLkAAp0Ory4Buc","vkPi4GpRL1LrmTRh3TSg","FyWP3BUb13yHI7CIQV8o","DUyhPA9v5Zvr9i6RDZ7h","BGOU33xCIRtZW6CB3EQP","FEnVgChU97fxlV4VYDe0","SxbbgMi2augHXTfK3T8C","qF0mYupPvMVSaYCW39aD","fu67DJlcPjyvOCri6UPg","31YAoX2NI8suoAfqEwKU","kkE7IxyRo472Ufj4LaNe","JjiR4uAJeN3QI8I8nIxE","hnNcFB6qkdi5WGnIb4uJ","BkokGCD2kKJzQPYlmMIs","WkozxK73wvLURpOAX1QF","fzcWNGNDdT5lk52YAAys","Nm2sEVS2ipHTajEGrctk","afAsUkY0VpkRK9KTWFQT"],"label":"Tests centrés sur isValid","tests":[{"params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"}],"comment":"P1 at start","expect":{"valid":true},"id":"9zz2MWHIDHnricejPYEG","op":"isValid"},{"result":{"valid":true},"op":"isValid","pass":true,"params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P2"}],"id":"zahqfNcLkAAp0Ory4Buc","expect":{"reason":"not the turn of P2","valid":false},"comment":"P2 at start is invalid (not the turn of P2)"},{"expect":{"valid":false,"reason":"column 1 has too much tokens"},"id":"vkPi4GpRL1LrmTRh3TSg","comment":"column 1 overload","params":[{"grid":[["P1","P2","P1","P2","P1","P2","P1"],[],[],[],[],[],[]],"turn":"P1"}],"op":"isValid"},{"params":[{"grid":[["P1","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1","P2"],[],[],[],[],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P2"}],"id":"FyWP3BUb13yHI7CIQV8o","expect":{"reason":"column 2 has too much tokens","valid":false},"comment":"column 2 overload","result":{"reason":"column 1 has too much tokens","valid":false},"pass":true,"op":"isValid"},{"pass":true,"params":[{"grid":[["P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1","P2"],[],[],[],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P1"}],"op":"isValid","comment":"column 3 overload","id":"DUyhPA9v5Zvr9i6RDZ7h","result":{"valid":false,"reason":"column 2 has too much tokens"},"expect":{"valid":false,"reason":"column 3 has too much tokens"}},{"result":{"valid":false,"reason":"column 3 has too much tokens"},"pass":true,"comment":"column 4 overload","expect":{"reason":"column 4 has too much tokens","valid":false},"id":"BGOU33xCIRtZW6CB3EQP","params":[{"grid":[["P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2","P1","P2","P1","P2","P1"],[],[],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P1"}],"op":"isValid"},{"op":"isValid","id":"FEnVgChU97fxlV4VYDe0","comment":"column 5 overload","params":[{"grid":[["P1","P2","P1","P2"],["P2","P1"],["P2","P1","P2","P1"],["P1","P2","P1"],["P2","P2","P1","P2","P1","P2","P1","P2","P1"],[],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P1"}],"pass":true,"result":{"valid":false,"reason":"column 4 has too much tokens"},"expect":{"valid":false,"reason":"column 5 has too much tokens"}},{"expect":{"reason":"column 6 has too much tokens","valid":false},"pass":true,"result":{"reason":"column 5 has too much tokens","valid":false},"comment":"column 6 overload","id":"SxbbgMi2augHXTfK3T8C","params":[{"grid":[["P1","P2","P1","P2"],["P2","P1"],["P2","P1","P2","P1"],["P1","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P1"}],"op":"isValid"},{"pass":true,"comment":"column 7 overload","params":[{"grid":[["P1","P2","P1","P2"],["P2","P1","P2"],["P2","P1","P2","P1"],["P1","P2","P1","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P1"}],"id":"qF0mYupPvMVSaYCW39aD","op":"isValid","result":{"valid":false,"reason":"column 6 has too much tokens"},"expect":{"reason":"column 7 has too much tokens","valid":false}},{"params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2"],["P2","P1","P2","P1","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"result":{"reason":"column 7 has too much tokens","valid":false},"pass":true,"expect":{"valid":false,"reason":"not the turn of P1"},"id":"fu67DJlcPjyvOCri6UPg","comment":"Not the turn of P1","op":"isValid"},{"params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P2"}],"op":"isValid","pass":false,"result":{"reason":"There cannot be two winners","valid":false},"expect":{"reason":"not the turn of P2","valid":false},"id":"31YAoX2NI8suoAfqEwKU","comment":"Not the turn of P2"},{"expect":{"valid":false,"reason":"There cannot be two winners"},"result":{"reason":"not the turn of P2","valid":false},"comment":"There cannot be 2 winners","params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"op":"isValid","pass":true,"id":"kkE7IxyRo472Ufj4LaNe"},{"result":{"reason":"There cannot be two winners","valid":false},"comment":"There cannot be 2 winners (simple)","id":"JjiR4uAJeN3QI8I8nIxE","expect":{"reason":"There cannot be two winners","valid":false},"pass":true,"params":[{"grid":[[],["P1"],["P1","P1"],["P1","P1","P1","P2"],["P2","P2","P2","P1"],["P2","P2"],["P2"]],"turn":"P1"}],"op":"isValid"},{"comment":"There cannot be 2 winners (simple 2 )","pass":true,"params":[{"grid":[["P2","P2"],["P1","P1"],["P1","P1","P2","P1"],["P1","P1","P1","P2","P1"],["P2","P1","P2"],["P2","P2"],["P2"]],"turn":"P2"}],"op":"isValid","expect":{"valid":false,"reason":"There cannot be two winners"},"result":{"valid":false,"reason":"There cannot be two winners"},"id":"hnNcFB6qkdi5WGnIb4uJ"},{"comment":"no two winners (P2 first winner to be detected)","params":[{"turn":"P2","grid":[["P2"],["P2"],["P2"],["P2"],[],["P1"],["P1","P1","P1","P1"]]}],"op":"isValid","id":"BkokGCD2kKJzQPYlmMIs","expect":{"reason":"There cannot be two winners","valid":false}},{"id":"WkozxK73wvLURpOAX1QF","comment":"Too much token for P1(P2 turn)","result":{"returns":{"valid":false,"reason":"not the turn of P2"},"exec":"success"},"expect":{"valid":false,"reason":"too much token for P1"},"pass":true,"params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2","P1","P1"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P2"}],"op":"isValid"},{"comment":"Too much token for P1(P1 turn)","params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2","P1","P1"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"op":"isValid","pass":true,"expect":{"reason":"too much token for P1","valid":false},"id":"fzcWNGNDdT5lk52YAAys","result":{"exec":"success","returns":{"reason":"too much token for P1","valid":false}}},{"pass":true,"expect":{"reason":"too much token for P2","valid":false},"comment":"Too much token for P2(P1 turn)","id":"Nm2sEVS2ipHTajEGrctk","result":{"exec":"success","returns":{"valid":false,"reason":"too much token for P1"}},"op":"isValid","params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}]},{"params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P2"}],"id":"afAsUkY0VpkRK9KTWFQT","pass":true,"expect":{"valid":false,"reason":"too much token for P2"},"comment":"Too much token for P2(P2 turn)","op":"isValid","result":{"returns":{"valid":false,"reason":"too much token for P2"},"exec":"success"}}]},{"LtestIds":["glLaSQXbmUmgBmp6r2Mm","syiCwg8OD3K1W9EF92t9","kW4LcQzWEq6X00x7HBO5","TKHBHQcld9qDMXYQPj7q","5FOBGLPXH8u8QIIX6G0V","beZzzcq4SOmoXL0oGu6w","LuHz9ZxboUtXSIWigbBK","8ujgWEKhQzj6zjuyXSrw","batpdJsyIgc43I7q6xJC","MZAKmTYHM7ilFnG8jvy7","HeBTqTGBhTX1mD2MS5Y0","b92FbWdyOFIRT9j4H1x4","3PLGMtvnuwx2XtWjdl82","wBa7XMsYYhuUE07uxMsj","pcVytVFoXLDk5eQDoaXy","tGMb50UQ2JRMiXRnZOgr","9yWW3X0eQ1MagqBZ0Kwj","s9tb4tbHC18IMnq8Qv1F","Vm2yyQtmdHg5XhKkrIo8","2EozqANDNIsWdZt0rx84"],"id":"Iokl5GpxtANX776ava1K","label":"Tests centrés sur winner","tests":[{"op":"isValid","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],[],[],[],[],[],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"comment":"First and last column full, no winner yet","expect":{"valid":true},"id":"glLaSQXbmUmgBmp6r2Mm"},{"params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"}],"op":"winner","id":"syiCwg8OD3K1W9EF92t9","expect":"no winner yet","comment":"no winner at beginning"},{"expect":{"valid":true},"pass":true,"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"result":{"valid":true},"id":"kW4LcQzWEq6X00x7HBO5","comment":"valid full grid ","op":"isValid"},{"expect":"DRAW","op":"winner","result":{"valid":true},"id":"TKHBHQcld9qDMXYQPj7q","pass":true,"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"comment":"valid full grid DRAW"},{"op":"isValid","result":"DRAW","id":"5FOBGLPXH8u8QIIX6G0V","comment":"P1 win is valid (horizontal)","pass":true,"expect":{"valid":true},"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2"],["P1","P2","P1","P2"],["P2","P1","P2","P1","P1"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P2"}]},{"result":{"valid":true},"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2"],["P1","P2","P1","P2"],["P2","P1","P2","P1","P1"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P2"}],"pass":true,"op":"winner","comment":"P1 win  (horizontal)","expect":"P1","id":"beZzzcq4SOmoXL0oGu6w"},{"op":"winner","expect":"P2","result":"P1","id":"LuHz9ZxboUtXSIWigbBK","pass":true,"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2"],["P1","P2","P1","P1"],["P2","P1","P2","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"comment":"P2 win  (horizontal)"},{"result":"P2","pass":true,"comment":"P2 win is valid  (horizontal)","op":"isValid","expect":{"valid":true},"id":"8ujgWEKhQzj6zjuyXSrw","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2"],["P1","P2","P1","P1"],["P2","P1","P2","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}]},{"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P1","P2","P1","P1"],["P2","P1","P2"],["P1","P2","P1","P2","P1","P1"],["P1","P2","P1","P2","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"op":"isValid","result":{"valid":true},"comment":"P2 win is valid  (North-East)","pass":true,"expect":{"valid":true},"id":"batpdJsyIgc43I7q6xJC"},{"id":"MZAKmTYHM7ilFnG8jvy7","expect":"P2","result":{"valid":true},"comment":"P2 win  (North-East)","op":"winner","pass":true,"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P1","P2","P1","P1"],["P2","P1","P2"],["P1","P2","P1","P2","P1","P1"],["P1","P2","P1","P2","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}]},{"pass":true,"expect":{"valid":true},"result":"P2","op":"isValid","comment":"P1 win is valid (North-East)","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P2","P1","P2"],["P2","P1","P1"],["P1","P2","P2","P1"],["P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P1"]],"turn":"P2"}],"id":"HeBTqTGBhTX1mD2MS5Y0"},{"expect":"P1","result":{"valid":true},"pass":true,"comment":"P1 win (North-East)","id":"b92FbWdyOFIRT9j4H1x4","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P2","P1","P2"],["P2","P1","P1"],["P1","P2","P2","P1"],["P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P1"]],"turn":"P2"}],"op":"winner"},{"result":"P1","comment":"P1 win (South-East)","op":"winner","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P2","P1","P2","P1"],["P2","P1","P1","P2","P1"],["P1","P2","P2","P1"],["P1","P2","P1","P2","P1"],["P1","P1","P2"]],"turn":"P2"}],"id":"3PLGMtvnuwx2XtWjdl82","pass":true,"expect":"P1"},{"result":{"valid":true},"id":"wBa7XMsYYhuUE07uxMsj","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P2","P1","P2","P1"],["P2","P1","P1","P2","P1"],["P1","P2","P2","P1"],["P1","P2","P1","P2","P1"],["P1","P1","P2"]],"turn":"P2"}],"comment":"P1 win is valid (South-East)","op":"isValid","expect":{"valid":true},"pass":true},{"op":"isValid","pass":true,"id":"pcVytVFoXLDk5eQDoaXy","params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1"],["P2","P1","P2","P1","P2"],["P2","P1","P1","P2","P1"],["P1","P2","P2"],["P1","P2","P1","P2"],["P1","P2","P2"]],"turn":"P1"}],"expect":{"valid":true},"comment":"P2 win is valid (South-East)","result":{"valid":true}},{"comment":"P1 win is valid (Vertical)","id":"tGMb50UQ2JRMiXRnZOgr","op":"isValid","pass":true,"result":{"valid":true},"expect":{"valid":true},"params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1"],["P2","P1","P2","P1"],["P2","P1","P1","P1","P1"],["P1","P2","P2"],["P1","P2","P1","P2","P2"],["P1","P2","P2","P2"]],"turn":"P2"}]},{"params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1"],["P2","P1","P2","P1"],["P2","P1","P1","P1","P1"],["P1","P2","P2"],["P1","P2","P1","P2","P2"],["P1","P2","P2","P2"]],"turn":"P2"}],"expect":"P1","id":"9yWW3X0eQ1MagqBZ0Kwj","result":{"valid":true},"op":"winner","comment":"P1 win (Vertical)","pass":true},{"result":"P1","id":"s9tb4tbHC18IMnq8Qv1F","expect":{"valid":true},"comment":"P2 win is valid (Vertical)","pass":true,"op":"isValid","params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1","P1"],["P2","P1","P2","P1"],["P2","P1","P1","P1"],["P1","P2","P2"],["P1","P2","P1","P2","P2"],["P1","P2","P2","P2","P2"]],"turn":"P1"}]},{"result":{"valid":true},"op":"winner","pass":true,"comment":"P2 win (Vertical)","id":"Vm2yyQtmdHg5XhKkrIo8","params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1","P1"],["P2","P1","P2","P1"],["P2","P1","P1","P1"],["P1","P2","P2"],["P1","P2","P1","P2","P2"],["P1","P2","P2","P2","P2"]],"turn":"P1"}],"expect":"P2"},{"op":"winner","expect":"P2","comment":"P2 win (South-East)","id":"2EozqANDNIsWdZt0rx84","params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1"],["P2","P1","P2","P1","P2"],["P2","P1","P1","P2","P1"],["P1","P2","P2"],["P1","P2","P1","P2"],["P1","P2","P2"]],"turn":"P1"}],"result":{"valid":true},"pass":true}]},{"label":"Tests centrés sur play","LtestIds":["b4kZF25jBSAuBzFN2qXJ","qcfoC7J2Xuyco68urGt5","R2CYLCliEJ6NMzhwinXP","yChU1qBNQNgh6JQ6WvWH","iCqK3kWJzOMsJ2sc8T9h","Q27G8Ha2dR9bYTvUoL6M","ID1QEDyJelNSuQX31wsq","wrhW8AJ3bqGfIBraGO7E","wyjsQEs96yujowPxSvyK","phjLRjzsSpDMaFN9TPxm","QAU8unGFzPlAePNGcj7B","9Y6TAKJm1vlKbkfN5TcA","THzFebM3mnvxc8eWE62A","7sPqLgqlM5YuZmpT8o54"],"id":"vLSmQjtYL408m9TPGq5G","tests":[{"comment":"second coup sur 4","id":"b4kZF25jBSAuBzFN2qXJ","expect":{"state":{"grid":[["P1"],["P2"],[],["P1"],[],[],[]],"turn":"P2"},"success":true},"params":[{"grid":[["P1"],["P2"],[],[],[],[],[]],"turn":"P1"},4],"op":"play"},{"op":"play","id":"qcfoC7J2Xuyco68urGt5","params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"},1],"expect":{"state":{"grid":[["P1"],[],[],[],[],[],[]],"turn":"P2"},"success":true},"comment":"play at 1"},{"params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"},2.1],"id":"R2CYLCliEJ6NMzhwinXP","expect":{"reason":"no such column","success":false},"op":"play","comment":"impossible to play at 2.1"},{"id":"yChU1qBNQNgh6JQ6WvWH","op":"play","params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"},0],"comment":"impossible to play at 0","expect":{"reason":"no such column","success":false}},{"comment":"possible to play at 7","expect":{"state":{"grid":[["P1"],["P1"],["P2","P2","P1"],["P1"],["P2","P2"],["P1"],["P2","P1","P2"]],"turn":"P1"},"success":true},"id":"iCqK3kWJzOMsJ2sc8T9h","params":[{"grid":[["P1"],["P1"],["P2","P2","P1"],["P1"],["P2","P2"],["P1"],["P2","P1"]],"turn":"P2"},7],"op":"play"},{"params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"},8],"id":"Q27G8Ha2dR9bYTvUoL6M","expect":{"success":false,"reason":"no such column"},"op":"play","comment":"Impossible to play at 8"},{"pass":true,"id":"ID1QEDyJelNSuQX31wsq","expect":{"valid":true},"comment":"Full grid is valid","result":{"success":false,"reason":"no such column"},"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"}],"op":"isValid"},{"expect":"DRAW","op":"winner","id":"wrhW8AJ3bqGfIBraGO7E","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"}],"result":{"valid":true},"comment":"Draw with full grid and player 1 turn","pass":true},{"result":"DRAW","comment":"Draw grid, cannot play at 1","expect":{"reason":"column is full","success":false},"id":"wyjsQEs96yujowPxSvyK","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},1],"pass":true,"op":"play"},{"pass":true,"op":"play","id":"phjLRjzsSpDMaFN9TPxm","result":{"success":false,"reason":"column is full"},"comment":"Draw grid, cannot play at 2","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},2],"expect":{"reason":"column is full","success":false}},{"expect":{"reason":"column is full","success":false},"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},3],"id":"QAU8unGFzPlAePNGcj7B","result":{"success":false,"reason":"column is full"},"comment":"Draw grid, cannot play at 3","op":"play","pass":true},{"comment":"Draw grid, cannot play at 5","pass":true,"op":"play","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},5],"expect":{"success":false,"reason":"column is full"},"id":"9Y6TAKJm1vlKbkfN5TcA","result":{"reason":"column is full","success":false}},{"pass":true,"comment":"Draw grid, cannot play at 6","id":"THzFebM3mnvxc8eWE62A","result":{"success":false,"reason":"column is full"},"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},6],"expect":{"success":false,"reason":"column is full"},"op":"play"},{"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},7],"pass":true,"expect":{"success":false,"reason":"column is full"},"comment":"Draw grid, cannot play at 7","op":"play","id":"7sPqLgqlM5YuZmpT8o54","result":{"reason":"column is full","success":false}}]}],"canObserve":["alexandre.demeure@univ-grenoble-alpes.fr","sybille.caffiau@univ-grenoble-alpes.fr"]}