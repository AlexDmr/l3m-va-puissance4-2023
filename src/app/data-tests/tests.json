{"userMail":"alexandre.demeure@univ-grenoble-alpes.fr","version":63,"mutants":[{"op":"isValid","comment":"no 2 winners","code":"function anonymous(state\n) {\n\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    return { valid: true };\n\n}","body":"\n\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"errors in reverse priority order","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0], [1, -1], [1, 1], [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0], [1, -1], [1, 1], [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"too much tokens <-> not turn of Pi","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0], [1, -1], [1, 1], [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 >= nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 >= nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0], [1, -1], [1, 1], [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 >= nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 >= nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"missing direction [1, -1]","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        // [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        // [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"Missing direction [1, 0]","code":"function anonymous(state\n) {\n\n    const directions = [\n        // [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        // [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"Mising direction [1, 1]","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        // [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        // [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"Missing direction [0, 1]","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        // [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        // [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"winnercond >=4    --->   >4","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb > 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb > 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"winnercond >= 3","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 3;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 3;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"bad column number (-1)","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c - 1} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c - 1} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"nbP1 > nbP2 /*+ 1*/","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 /*+ 1*/)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 /*+ 1*/)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"nbP2 > nbP1 + 1","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1 + 1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1 + 1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"col >= 6","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length >= 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length >= 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"nbP1 <-> nbP2","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP2 = nb(state, \"P1\");\n    const nbP1 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length >= 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP2 = nb(state, \"P1\");\n    const nbP1 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length >= 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"winner","comment":"nb > 4","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb > 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb > 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"Missing [1, 0]","code":"function anonymous(state\n) {\n\n    const directions = [\n        // [1, 0], \n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        // [1, 0], \n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"Missing  [1, -1]","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        // [1, -1], \n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        // [1, -1], \n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"Missing  [1, 1], ","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        // [1, 1], \n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        // [1, 1], \n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"Missing  [0, 1]","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        // [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        // [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"<= 6 ? \"DRAW\"","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length <= 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length <= 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"L.length === 6 ? \"DRAW\" ","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length === 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length === 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"play","comment":"COL.length > 6","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (COL === undefined) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length > 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (COL === undefined) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length > 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"column à virgule","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 1 || column > 7) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 1 || column > 7) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"column < 0 || column > 6 || !Number.isInteger(column)","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 0 || column > 6 || !Number.isInteger(column)) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 0 || column > 6 || !Number.isInteger(column)) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"column < 1 || column > 6 || !Number.isInteger(column) ","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 1 || column > 6 || !Number.isInteger(column)) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 1 || column > 6 || !Number.isInteger(column)) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"always P1","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"always P2","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: \"P2\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: \"P2\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"no turn change","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn,\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn,\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"wrong token","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.state.turn === \"P1\" ? \"P2\" : \"P1\"])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.state.turn === \"P1\" ? \"P2\" : \"P1\"])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"wrong column","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== (c + 1) ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== (c + 1) ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]}],"suites":[{"LtestIds":["9zz2MWHIDHnricejPYEG","zahqfNcLkAAp0Ory4Buc","vkPi4GpRL1LrmTRh3TSg","FyWP3BUb13yHI7CIQV8o","DUyhPA9v5Zvr9i6RDZ7h","BGOU33xCIRtZW6CB3EQP","FEnVgChU97fxlV4VYDe0","SxbbgMi2augHXTfK3T8C","qF0mYupPvMVSaYCW39aD","fu67DJlcPjyvOCri6UPg","31YAoX2NI8suoAfqEwKU","kkE7IxyRo472Ufj4LaNe","JjiR4uAJeN3QI8I8nIxE","hnNcFB6qkdi5WGnIb4uJ","BkokGCD2kKJzQPYlmMIs","WkozxK73wvLURpOAX1QF","fzcWNGNDdT5lk52YAAys","Nm2sEVS2ipHTajEGrctk","afAsUkY0VpkRK9KTWFQT"],"label":"Tests centrés sur isValid","id":"CLtMNpXwwUuXorvRyWtK","tests":[{"expect":{"valid":true},"params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"}],"comment":"P1 at start","op":"isValid","id":"9zz2MWHIDHnricejPYEG"},{"comment":"P2 at start is invalid (not the turn of P2)","result":{"valid":true},"expect":{"reason":"not the turn of P2","valid":false},"pass":true,"id":"zahqfNcLkAAp0Ory4Buc","params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P2"}],"op":"isValid"},{"id":"vkPi4GpRL1LrmTRh3TSg","params":[{"grid":[["P1","P2","P1","P2","P1","P2","P1"],[],[],[],[],[],[]],"turn":"P1"}],"comment":"column 1 overload","op":"isValid","expect":{"valid":false,"reason":"column 1 has too much tokens"}},{"id":"FyWP3BUb13yHI7CIQV8o","result":{"reason":"column 1 has too much tokens","valid":false},"comment":"column 2 overload","params":[{"grid":[["P1","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1","P2"],[],[],[],[],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P2"}],"op":"isValid","expect":{"valid":false,"reason":"column 2 has too much tokens"},"pass":true},{"expect":{"valid":false,"reason":"column 3 has too much tokens"},"params":[{"grid":[["P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1","P2"],[],[],[],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P1"}],"result":{"reason":"column 2 has too much tokens","valid":false},"comment":"column 3 overload","pass":true,"id":"DUyhPA9v5Zvr9i6RDZ7h","op":"isValid"},{"op":"isValid","pass":true,"result":{"reason":"column 3 has too much tokens","valid":false},"comment":"column 4 overload","id":"BGOU33xCIRtZW6CB3EQP","params":[{"grid":[["P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2","P1","P2","P1","P2","P1"],[],[],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P1"}],"expect":{"valid":false,"reason":"column 4 has too much tokens"}},{"id":"FEnVgChU97fxlV4VYDe0","expect":{"reason":"column 5 has too much tokens","valid":false},"params":[{"grid":[["P1","P2","P1","P2"],["P2","P1"],["P2","P1","P2","P1"],["P1","P2","P1"],["P2","P2","P1","P2","P1","P2","P1","P2","P1"],[],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P1"}],"result":{"reason":"column 4 has too much tokens","valid":false},"op":"isValid","comment":"column 5 overload","pass":true},{"params":[{"grid":[["P1","P2","P1","P2"],["P2","P1"],["P2","P1","P2","P1"],["P1","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P1"}],"comment":"column 6 overload","result":{"reason":"column 5 has too much tokens","valid":false},"id":"SxbbgMi2augHXTfK3T8C","pass":true,"expect":{"reason":"column 6 has too much tokens","valid":false},"op":"isValid"},{"params":[{"grid":[["P1","P2","P1","P2"],["P2","P1","P2"],["P2","P1","P2","P1"],["P1","P2","P1","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P1"}],"comment":"column 7 overload","expect":{"valid":false,"reason":"column 7 has too much tokens"},"pass":true,"op":"isValid","result":{"valid":false,"reason":"column 6 has too much tokens"},"id":"qF0mYupPvMVSaYCW39aD"},{"pass":true,"params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2"],["P2","P1","P2","P1","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"expect":{"reason":"not the turn of P1","valid":false},"comment":"Not the turn of P1","op":"isValid","id":"fu67DJlcPjyvOCri6UPg","result":{"valid":false,"reason":"column 7 has too much tokens"}},{"pass":false,"id":"31YAoX2NI8suoAfqEwKU","comment":"Not the turn of P2","params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P2"}],"result":{"valid":false,"reason":"There cannot be two winners"},"op":"isValid","expect":{"reason":"not the turn of P2","valid":false}},{"result":{"reason":"not the turn of P2","valid":false},"pass":true,"expect":{"valid":false,"reason":"There cannot be two winners"},"id":"kkE7IxyRo472Ufj4LaNe","op":"isValid","comment":"There cannot be 2 winners","params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}]},{"op":"isValid","expect":{"reason":"There cannot be two winners","valid":false},"params":[{"grid":[[],["P1"],["P1","P1"],["P1","P1","P1","P2"],["P2","P2","P2","P1"],["P2","P2"],["P2"]],"turn":"P1"}],"result":{"valid":false,"reason":"There cannot be two winners"},"pass":true,"comment":"There cannot be 2 winners (simple)","id":"JjiR4uAJeN3QI8I8nIxE"},{"params":[{"grid":[["P2","P2"],["P1","P1"],["P1","P1","P2","P1"],["P1","P1","P1","P2","P1"],["P2","P1","P2"],["P2","P2"],["P2"]],"turn":"P2"}],"expect":{"reason":"There cannot be two winners","valid":false},"comment":"There cannot be 2 winners (simple 2 )","id":"hnNcFB6qkdi5WGnIb4uJ","pass":true,"result":{"valid":false,"reason":"There cannot be two winners"},"op":"isValid"},{"op":"isValid","expect":{"reason":"There cannot be two winners","valid":false},"comment":"no two winners (P2 first winner to be detected)","id":"BkokGCD2kKJzQPYlmMIs","params":[{"turn":"P2","grid":[["P2"],["P2"],["P2"],["P2"],[],["P1"],["P1","P1","P1","P1"]]}]},{"expect":{"reason":"too much token for P1","valid":false},"comment":"Too much token for P1(P2 turn)","id":"WkozxK73wvLURpOAX1QF","pass":true,"op":"isValid","result":{"exec":"success","returns":{"reason":"not the turn of P2","valid":false}},"params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2","P1","P1"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P2"}]},{"result":{"exec":"success","returns":{"reason":"too much token for P1","valid":false}},"params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2","P1","P1"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"comment":"Too much token for P1(P1 turn)","expect":{"valid":false,"reason":"too much token for P1"},"pass":true,"id":"fzcWNGNDdT5lk52YAAys","op":"isValid"},{"id":"Nm2sEVS2ipHTajEGrctk","pass":true,"result":{"returns":{"reason":"too much token for P1","valid":false},"exec":"success"},"op":"isValid","params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"expect":{"valid":false,"reason":"too much token for P2"},"comment":"Too much token for P2(P1 turn)"},{"result":{"returns":{"valid":false,"reason":"too much token for P2"},"exec":"success"},"comment":"Too much token for P2(P2 turn)","op":"isValid","expect":{"reason":"too much token for P2","valid":false},"params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P2"}],"pass":true,"id":"afAsUkY0VpkRK9KTWFQT"}]},{"LtestIds":["glLaSQXbmUmgBmp6r2Mm","syiCwg8OD3K1W9EF92t9","kW4LcQzWEq6X00x7HBO5","TKHBHQcld9qDMXYQPj7q","5FOBGLPXH8u8QIIX6G0V","beZzzcq4SOmoXL0oGu6w","LuHz9ZxboUtXSIWigbBK","8ujgWEKhQzj6zjuyXSrw","batpdJsyIgc43I7q6xJC","MZAKmTYHM7ilFnG8jvy7","HeBTqTGBhTX1mD2MS5Y0","b92FbWdyOFIRT9j4H1x4","3PLGMtvnuwx2XtWjdl82","wBa7XMsYYhuUE07uxMsj","pcVytVFoXLDk5eQDoaXy","tGMb50UQ2JRMiXRnZOgr","9yWW3X0eQ1MagqBZ0Kwj","s9tb4tbHC18IMnq8Qv1F","Vm2yyQtmdHg5XhKkrIo8","2EozqANDNIsWdZt0rx84"],"id":"Iokl5GpxtANX776ava1K","label":"Tests centrés sur winner","tests":[{"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],[],[],[],[],[],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"comment":"First and last column full, no winner yet","op":"isValid","id":"glLaSQXbmUmgBmp6r2Mm","expect":{"valid":true}},{"params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"}],"comment":"no winner at beginning","op":"winner","id":"syiCwg8OD3K1W9EF92t9","expect":"no winner yet"},{"result":{"valid":true},"pass":true,"op":"isValid","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"comment":"valid full grid ","expect":{"valid":true},"id":"kW4LcQzWEq6X00x7HBO5"},{"pass":true,"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"id":"TKHBHQcld9qDMXYQPj7q","comment":"valid full grid DRAW","expect":"DRAW","result":{"valid":true},"op":"winner"},{"id":"5FOBGLPXH8u8QIIX6G0V","op":"isValid","result":"DRAW","comment":"P1 win is valid (horizontal)","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2"],["P1","P2","P1","P2"],["P2","P1","P2","P1","P1"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P2"}],"pass":true,"expect":{"valid":true}},{"id":"beZzzcq4SOmoXL0oGu6w","op":"winner","comment":"P1 win  (horizontal)","expect":"P1","result":{"valid":true},"pass":true,"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2"],["P1","P2","P1","P2"],["P2","P1","P2","P1","P1"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P2"}]},{"pass":true,"expect":"P2","id":"LuHz9ZxboUtXSIWigbBK","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2"],["P1","P2","P1","P1"],["P2","P1","P2","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"comment":"P2 win  (horizontal)","op":"winner","result":"P1"},{"result":"P2","comment":"P2 win is valid  (horizontal)","pass":true,"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2"],["P1","P2","P1","P1"],["P2","P1","P2","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"op":"isValid","id":"8ujgWEKhQzj6zjuyXSrw","expect":{"valid":true}},{"pass":true,"op":"isValid","result":{"valid":true},"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P1","P2","P1","P1"],["P2","P1","P2"],["P1","P2","P1","P2","P1","P1"],["P1","P2","P1","P2","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"expect":{"valid":true},"id":"batpdJsyIgc43I7q6xJC","comment":"P2 win is valid  (North-East)"},{"pass":true,"expect":"P2","id":"MZAKmTYHM7ilFnG8jvy7","op":"winner","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P1","P2","P1","P1"],["P2","P1","P2"],["P1","P2","P1","P2","P1","P1"],["P1","P2","P1","P2","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"comment":"P2 win  (North-East)","result":{"valid":true}},{"expect":{"valid":true},"pass":true,"result":"P2","comment":"P1 win is valid (North-East)","id":"HeBTqTGBhTX1mD2MS5Y0","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P2","P1","P2"],["P2","P1","P1"],["P1","P2","P2","P1"],["P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P1"]],"turn":"P2"}],"op":"isValid"},{"id":"b92FbWdyOFIRT9j4H1x4","pass":true,"expect":"P1","comment":"P1 win (North-East)","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P2","P1","P2"],["P2","P1","P1"],["P1","P2","P2","P1"],["P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P1"]],"turn":"P2"}],"result":{"valid":true},"op":"winner"},{"op":"winner","expect":"P1","id":"3PLGMtvnuwx2XtWjdl82","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P2","P1","P2","P1"],["P2","P1","P1","P2","P1"],["P1","P2","P2","P1"],["P1","P2","P1","P2","P1"],["P1","P1","P2"]],"turn":"P2"}],"comment":"P1 win (South-East)","result":"P1","pass":true},{"expect":{"valid":true},"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P2","P1","P2","P1"],["P2","P1","P1","P2","P1"],["P1","P2","P2","P1"],["P1","P2","P1","P2","P1"],["P1","P1","P2"]],"turn":"P2"}],"comment":"P1 win is valid (South-East)","id":"wBa7XMsYYhuUE07uxMsj","result":{"valid":true},"pass":true,"op":"isValid"},{"op":"isValid","comment":"P2 win is valid (South-East)","pass":true,"id":"pcVytVFoXLDk5eQDoaXy","result":{"valid":true},"expect":{"valid":true},"params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1"],["P2","P1","P2","P1","P2"],["P2","P1","P1","P2","P1"],["P1","P2","P2"],["P1","P2","P1","P2"],["P1","P2","P2"]],"turn":"P1"}]},{"expect":{"valid":true},"op":"isValid","pass":true,"id":"tGMb50UQ2JRMiXRnZOgr","result":{"valid":true},"comment":"P1 win is valid (Vertical)","params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1"],["P2","P1","P2","P1"],["P2","P1","P1","P1","P1"],["P1","P2","P2"],["P1","P2","P1","P2","P2"],["P1","P2","P2","P2"]],"turn":"P2"}]},{"result":{"valid":true},"pass":true,"comment":"P1 win (Vertical)","id":"9yWW3X0eQ1MagqBZ0Kwj","params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1"],["P2","P1","P2","P1"],["P2","P1","P1","P1","P1"],["P1","P2","P2"],["P1","P2","P1","P2","P2"],["P1","P2","P2","P2"]],"turn":"P2"}],"expect":"P1","op":"winner"},{"pass":true,"id":"s9tb4tbHC18IMnq8Qv1F","comment":"P2 win is valid (Vertical)","params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1","P1"],["P2","P1","P2","P1"],["P2","P1","P1","P1"],["P1","P2","P2"],["P1","P2","P1","P2","P2"],["P1","P2","P2","P2","P2"]],"turn":"P1"}],"result":"P1","expect":{"valid":true},"op":"isValid"},{"op":"winner","expect":"P2","params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1","P1"],["P2","P1","P2","P1"],["P2","P1","P1","P1"],["P1","P2","P2"],["P1","P2","P1","P2","P2"],["P1","P2","P2","P2","P2"]],"turn":"P1"}],"comment":"P2 win (Vertical)","pass":true,"id":"Vm2yyQtmdHg5XhKkrIo8","result":{"valid":true}},{"id":"2EozqANDNIsWdZt0rx84","expect":"P2","params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1"],["P2","P1","P2","P1","P2"],["P2","P1","P1","P2","P1"],["P1","P2","P2"],["P1","P2","P1","P2"],["P1","P2","P2"]],"turn":"P1"}],"result":{"valid":true},"op":"winner","comment":"P2 win (South-East)","pass":true}]},{"label":"Tests centrés sur play","LtestIds":["b4kZF25jBSAuBzFN2qXJ","qcfoC7J2Xuyco68urGt5","R2CYLCliEJ6NMzhwinXP","yChU1qBNQNgh6JQ6WvWH","iCqK3kWJzOMsJ2sc8T9h","Q27G8Ha2dR9bYTvUoL6M","ID1QEDyJelNSuQX31wsq","wrhW8AJ3bqGfIBraGO7E","wyjsQEs96yujowPxSvyK","phjLRjzsSpDMaFN9TPxm","QAU8unGFzPlAePNGcj7B","9Y6TAKJm1vlKbkfN5TcA","THzFebM3mnvxc8eWE62A","7sPqLgqlM5YuZmpT8o54"],"id":"vLSmQjtYL408m9TPGq5G","tests":[{"id":"b4kZF25jBSAuBzFN2qXJ","expect":{"success":true,"state":{"grid":[["P1"],["P2"],[],["P1"],[],[],[]],"turn":"P2"}},"comment":"second coup sur 4","params":[{"grid":[["P1"],["P2"],[],[],[],[],[]],"turn":"P1"},4],"op":"play"},{"expect":{"success":true,"state":{"grid":[["P1"],[],[],[],[],[],[]],"turn":"P2"}},"comment":"play at 1","op":"play","id":"qcfoC7J2Xuyco68urGt5","params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"},1]},{"op":"play","params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"},2.1],"expect":{"reason":"no such column","success":false},"comment":"impossible to play at 2.1","id":"R2CYLCliEJ6NMzhwinXP"},{"op":"play","comment":"impossible to play at 0","params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"},0],"id":"yChU1qBNQNgh6JQ6WvWH","expect":{"reason":"no such column","success":false}},{"params":[{"grid":[["P1"],["P1"],["P2","P2","P1"],["P1"],["P2","P2"],["P1"],["P2","P1"]],"turn":"P2"},7],"id":"iCqK3kWJzOMsJ2sc8T9h","expect":{"success":true,"state":{"grid":[["P1"],["P1"],["P2","P2","P1"],["P1"],["P2","P2"],["P1"],["P2","P1","P2"]],"turn":"P1"}},"comment":"possible to play at 7","op":"play"},{"op":"play","id":"Q27G8Ha2dR9bYTvUoL6M","expect":{"success":false,"reason":"no such column"},"params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"},8],"comment":"Impossible to play at 8"},{"expect":{"valid":true},"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"}],"id":"ID1QEDyJelNSuQX31wsq","op":"isValid","result":{"reason":"no such column","success":false},"comment":"Full grid is valid","pass":true},{"op":"winner","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"}],"result":{"valid":true},"pass":true,"id":"wrhW8AJ3bqGfIBraGO7E","comment":"Draw with full grid and player 1 turn","expect":"DRAW"},{"pass":true,"id":"wyjsQEs96yujowPxSvyK","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},1],"op":"play","result":"DRAW","expect":{"reason":"column is full","success":false},"comment":"Draw grid, cannot play at 1"},{"pass":true,"result":{"reason":"column is full","success":false},"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},2],"id":"phjLRjzsSpDMaFN9TPxm","expect":{"success":false,"reason":"column is full"},"comment":"Draw grid, cannot play at 2","op":"play"},{"comment":"Draw grid, cannot play at 3","op":"play","expect":{"success":false,"reason":"column is full"},"result":{"success":false,"reason":"column is full"},"id":"QAU8unGFzPlAePNGcj7B","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},3],"pass":true},{"pass":true,"result":{"success":false,"reason":"column is full"},"expect":{"success":false,"reason":"column is full"},"op":"play","comment":"Draw grid, cannot play at 5","id":"9Y6TAKJm1vlKbkfN5TcA","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},5]},{"pass":true,"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},6],"result":{"reason":"column is full","success":false},"op":"play","comment":"Draw grid, cannot play at 6","id":"THzFebM3mnvxc8eWE62A","expect":{"success":false,"reason":"column is full"}},{"pass":true,"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},7],"result":{"reason":"column is full","success":false},"expect":{"success":false,"reason":"column is full"},"id":"7sPqLgqlM5YuZmpT8o54","op":"play","comment":"Draw grid, cannot play at 7"}]}],"canObserve":[],"evals":[63,{"isValid":[30,30],"winner":[11,11],"play":[12,12]},{"play":[9,9],"isValid":[14,14],"winner":[7,7]}]}