export const dataTests = {"userMail":"alexandre.demeure@univ-grenoble-alpes.fr","version":63,"mutants":[{"op":"isValid","comment":"no 2 winners","code":"function anonymous(state\n) {\n\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    return { valid: true };\n\n}","body":"\n\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"errors in reverse priority order","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0], [1, -1], [1, 1], [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0], [1, -1], [1, 1], [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"too much tokens <-> not turn of Pi","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0], [1, -1], [1, 1], [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 >= nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 >= nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0], [1, -1], [1, 1], [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 >= nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 >= nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"missing direction [1, -1]","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        // [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        // [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"Missing direction [1, 0]","code":"function anonymous(state\n) {\n\n    const directions = [\n        // [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        // [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"Mising direction [1, 1]","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        // [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        // [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"Missing direction [0, 1]","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        // [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        // [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"winnercond >=4    --->   >4","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb > 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb > 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"winnercond >= 3","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 3;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 3;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"bad column number (-1)","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c - 1} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c - 1} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"nbP1 > nbP2 /*+ 1*/","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 /*+ 1*/)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 /*+ 1*/)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"nbP2 > nbP1 + 1","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1 + 1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1 + 1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"col >= 6","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length >= 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length >= 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"nbP1 <-> nbP2","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP2 = nb(state, \"P1\");\n    const nbP1 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length >= 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP2 = nb(state, \"P1\");\n    const nbP1 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length >= 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"winner","comment":"nb > 4","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb > 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb > 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"Missing [1, 0]","code":"function anonymous(state\n) {\n\n    const directions = [\n        // [1, 0], \n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        // [1, 0], \n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"Missing  [1, -1]","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        // [1, -1], \n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        // [1, -1], \n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"Missing  [1, 1], ","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        // [1, 1], \n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        // [1, 1], \n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"Missing  [0, 1]","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        // [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        // [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"<= 6 ? \"DRAW\"","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length <= 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length <= 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"L.length === 6 ? \"DRAW\" ","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length === 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length === 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"play","comment":"COL.length > 6","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (COL === undefined) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length > 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (COL === undefined) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length > 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"column à virgule","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 1 || column > 7) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 1 || column > 7) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"column < 0 || column > 6 || !Number.isInteger(column)","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 0 || column > 6 || !Number.isInteger(column)) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 0 || column > 6 || !Number.isInteger(column)) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"column < 1 || column > 6 || !Number.isInteger(column) ","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 1 || column > 6 || !Number.isInteger(column)) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 1 || column > 6 || !Number.isInteger(column)) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"always P1","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"always P2","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: \"P2\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: \"P2\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"no turn change","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn,\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn,\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"wrong token","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.state.turn === \"P1\" ? \"P2\" : \"P1\"])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.state.turn === \"P1\" ? \"P2\" : \"P1\"])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"wrong column","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== (c + 1) ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== (c + 1) ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]}],"suites":[{"id":"CLtMNpXwwUuXorvRyWtK","label":"Tests centrés sur isValid","LtestIds":["9zz2MWHIDHnricejPYEG","zahqfNcLkAAp0Ory4Buc","vkPi4GpRL1LrmTRh3TSg","FyWP3BUb13yHI7CIQV8o","DUyhPA9v5Zvr9i6RDZ7h","BGOU33xCIRtZW6CB3EQP","FEnVgChU97fxlV4VYDe0","SxbbgMi2augHXTfK3T8C","qF0mYupPvMVSaYCW39aD","fu67DJlcPjyvOCri6UPg","31YAoX2NI8suoAfqEwKU","kkE7IxyRo472Ufj4LaNe","JjiR4uAJeN3QI8I8nIxE","hnNcFB6qkdi5WGnIb4uJ","BkokGCD2kKJzQPYlmMIs","WkozxK73wvLURpOAX1QF","fzcWNGNDdT5lk52YAAys","Nm2sEVS2ipHTajEGrctk","afAsUkY0VpkRK9KTWFQT"],"tests":[{"op":"isValid","comment":"P1 at start","params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"}],"expect":{"valid":true},"id":"9zz2MWHIDHnricejPYEG"},{"result":{"valid":true},"comment":"P2 at start is invalid (not the turn of P2)","op":"isValid","expect":{"reason":"not the turn of P2","valid":false},"id":"zahqfNcLkAAp0Ory4Buc","pass":true,"params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P2"}]},{"expect":{"reason":"column 1 has too much tokens","valid":false},"params":[{"grid":[["P1","P2","P1","P2","P1","P2","P1"],[],[],[],[],[],[]],"turn":"P1"}],"op":"isValid","id":"vkPi4GpRL1LrmTRh3TSg","comment":"column 1 overload"},{"op":"isValid","id":"FyWP3BUb13yHI7CIQV8o","comment":"column 2 overload","params":[{"grid":[["P1","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1","P2"],[],[],[],[],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P2"}],"expect":{"valid":false,"reason":"column 2 has too much tokens"},"result":{"reason":"column 1 has too much tokens","valid":false},"pass":true},{"params":[{"grid":[["P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1","P2"],[],[],[],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P1"}],"op":"isValid","expect":{"valid":false,"reason":"column 3 has too much tokens"},"comment":"column 3 overload","result":{"reason":"column 2 has too much tokens","valid":false},"pass":true,"id":"DUyhPA9v5Zvr9i6RDZ7h"},{"id":"BGOU33xCIRtZW6CB3EQP","op":"isValid","params":[{"grid":[["P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2","P1","P2","P1","P2","P1"],[],[],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P1"}],"comment":"column 4 overload","expect":{"reason":"column 4 has too much tokens","valid":false},"result":{"reason":"column 3 has too much tokens","valid":false},"pass":true},{"comment":"column 5 overload","id":"FEnVgChU97fxlV4VYDe0","pass":true,"op":"isValid","expect":{"reason":"column 5 has too much tokens","valid":false},"result":{"valid":false,"reason":"column 4 has too much tokens"},"params":[{"grid":[["P1","P2","P1","P2"],["P2","P1"],["P2","P1","P2","P1"],["P1","P2","P1"],["P2","P2","P1","P2","P1","P2","P1","P2","P1"],[],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P1"}]},{"result":{"reason":"column 5 has too much tokens","valid":false},"op":"isValid","comment":"column 6 overload","pass":true,"params":[{"grid":[["P1","P2","P1","P2"],["P2","P1"],["P2","P1","P2","P1"],["P1","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P1"}],"id":"SxbbgMi2augHXTfK3T8C","expect":{"valid":false,"reason":"column 6 has too much tokens"}},{"result":{"valid":false,"reason":"column 6 has too much tokens"},"expect":{"valid":false,"reason":"column 7 has too much tokens"},"pass":true,"op":"isValid","comment":"column 7 overload","id":"qF0mYupPvMVSaYCW39aD","params":[{"grid":[["P1","P2","P1","P2"],["P2","P1","P2"],["P2","P1","P2","P1"],["P1","P2","P1","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P1"}]},{"comment":"Not the turn of P1","result":{"reason":"column 7 has too much tokens","valid":false},"expect":{"valid":false,"reason":"not the turn of P1"},"id":"fu67DJlcPjyvOCri6UPg","pass":true,"params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2"],["P2","P1","P2","P1","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"op":"isValid"},{"expect":{"reason":"not the turn of P2","valid":false},"op":"isValid","comment":"Not the turn of P2","id":"31YAoX2NI8suoAfqEwKU","pass":false,"result":{"valid":false,"reason":"There cannot be two winners"},"params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P2"}]},{"params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"expect":{"valid":false,"reason":"There cannot be two winners"},"comment":"There cannot be 2 winners","op":"isValid","result":{"reason":"not the turn of P2","valid":false},"id":"kkE7IxyRo472Ufj4LaNe","pass":true},{"comment":"There cannot be 2 winners (simple)","expect":{"valid":false,"reason":"There cannot be two winners"},"id":"JjiR4uAJeN3QI8I8nIxE","params":[{"grid":[[],["P1"],["P1","P1"],["P1","P1","P1","P2"],["P2","P2","P2","P1"],["P2","P2"],["P2"]],"turn":"P1"}],"op":"isValid","result":{"reason":"There cannot be two winners","valid":false},"pass":true},{"pass":true,"id":"hnNcFB6qkdi5WGnIb4uJ","comment":"There cannot be 2 winners (simple 2 )","result":{"valid":false,"reason":"There cannot be two winners"},"op":"isValid","params":[{"grid":[["P2","P2"],["P1","P1"],["P1","P1","P2","P1"],["P1","P1","P1","P2","P1"],["P2","P1","P2"],["P2","P2"],["P2"]],"turn":"P2"}],"expect":{"valid":false,"reason":"There cannot be two winners"}},{"op":"isValid","comment":"no two winners (P2 first winner to be detected)","params":[{"turn":"P2","grid":[["P2"],["P2"],["P2"],["P2"],[],["P1"],["P1","P1","P1","P1"]]}],"expect":{"reason":"There cannot be two winners","valid":false},"id":"BkokGCD2kKJzQPYlmMIs"},{"expect":{"reason":"too much token for P1","valid":false},"pass":true,"result":{"returns":{"valid":false,"reason":"not the turn of P2"},"exec":"success"},"comment":"Too much token for P1(P2 turn)","id":"WkozxK73wvLURpOAX1QF","op":"isValid","params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2","P1","P1"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P2"}]},{"op":"isValid","expect":{"reason":"too much token for P1","valid":false},"result":{"returns":{"reason":"too much token for P1","valid":false},"exec":"success"},"id":"fzcWNGNDdT5lk52YAAys","pass":true,"params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2","P1","P1"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"comment":"Too much token for P1(P1 turn)"},{"pass":true,"comment":"Too much token for P2(P1 turn)","result":{"exec":"success","returns":{"valid":false,"reason":"too much token for P1"}},"expect":{"reason":"too much token for P2","valid":false},"id":"Nm2sEVS2ipHTajEGrctk","params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"op":"isValid"},{"params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P2"}],"id":"afAsUkY0VpkRK9KTWFQT","result":{"exec":"success","returns":{"valid":false,"reason":"too much token for P2"}},"op":"isValid","pass":true,"comment":"Too much token for P2(P2 turn)","expect":{"reason":"too much token for P2","valid":false}}]},{"label":"Tests centrés sur winner","id":"Iokl5GpxtANX776ava1K","LtestIds":["glLaSQXbmUmgBmp6r2Mm","syiCwg8OD3K1W9EF92t9","kW4LcQzWEq6X00x7HBO5","TKHBHQcld9qDMXYQPj7q","5FOBGLPXH8u8QIIX6G0V","beZzzcq4SOmoXL0oGu6w","LuHz9ZxboUtXSIWigbBK","8ujgWEKhQzj6zjuyXSrw","batpdJsyIgc43I7q6xJC","MZAKmTYHM7ilFnG8jvy7","HeBTqTGBhTX1mD2MS5Y0","b92FbWdyOFIRT9j4H1x4","3PLGMtvnuwx2XtWjdl82","wBa7XMsYYhuUE07uxMsj","pcVytVFoXLDk5eQDoaXy","tGMb50UQ2JRMiXRnZOgr","9yWW3X0eQ1MagqBZ0Kwj","s9tb4tbHC18IMnq8Qv1F","Vm2yyQtmdHg5XhKkrIo8","2EozqANDNIsWdZt0rx84"],"tests":[{"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],[],[],[],[],[],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"expect":{"valid":true},"op":"isValid","id":"glLaSQXbmUmgBmp6r2Mm","comment":"First and last column full, no winner yet"},{"id":"syiCwg8OD3K1W9EF92t9","op":"winner","expect":"no winner yet","comment":"no winner at beginning","params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"}]},{"result":{"valid":true},"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"expect":{"valid":true},"pass":true,"id":"kW4LcQzWEq6X00x7HBO5","op":"isValid","comment":"valid full grid "},{"op":"winner","comment":"valid full grid DRAW","expect":"DRAW","id":"TKHBHQcld9qDMXYQPj7q","result":{"valid":true},"pass":true,"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}]},{"result":"DRAW","expect":{"valid":true},"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2"],["P1","P2","P1","P2"],["P2","P1","P2","P1","P1"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P2"}],"comment":"P1 win is valid (horizontal)","pass":true,"op":"isValid","id":"5FOBGLPXH8u8QIIX6G0V"},{"expect":"P1","pass":true,"result":{"valid":true},"op":"winner","id":"beZzzcq4SOmoXL0oGu6w","comment":"P1 win  (horizontal)","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2"],["P1","P2","P1","P2"],["P2","P1","P2","P1","P1"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P2"}]},{"pass":true,"comment":"P2 win  (horizontal)","id":"LuHz9ZxboUtXSIWigbBK","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2"],["P1","P2","P1","P1"],["P2","P1","P2","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"op":"winner","result":"P1","expect":"P2"},{"id":"8ujgWEKhQzj6zjuyXSrw","expect":{"valid":true},"op":"isValid","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2"],["P1","P2","P1","P1"],["P2","P1","P2","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"comment":"P2 win is valid  (horizontal)","result":"P2","pass":true},{"pass":true,"expect":{"valid":true},"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P1","P2","P1","P1"],["P2","P1","P2"],["P1","P2","P1","P2","P1","P1"],["P1","P2","P1","P2","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"id":"batpdJsyIgc43I7q6xJC","op":"isValid","result":{"valid":true},"comment":"P2 win is valid  (North-East)"},{"op":"winner","comment":"P2 win  (North-East)","pass":true,"result":{"valid":true},"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P1","P2","P1","P1"],["P2","P1","P2"],["P1","P2","P1","P2","P1","P1"],["P1","P2","P1","P2","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"expect":"P2","id":"MZAKmTYHM7ilFnG8jvy7"},{"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P2","P1","P2"],["P2","P1","P1"],["P1","P2","P2","P1"],["P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P1"]],"turn":"P2"}],"pass":true,"expect":{"valid":true},"comment":"P1 win is valid (North-East)","result":"P2","id":"HeBTqTGBhTX1mD2MS5Y0","op":"isValid"},{"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P2","P1","P2"],["P2","P1","P1"],["P1","P2","P2","P1"],["P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P1"]],"turn":"P2"}],"op":"winner","pass":true,"comment":"P1 win (North-East)","id":"b92FbWdyOFIRT9j4H1x4","result":{"valid":true},"expect":"P1"},{"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P2","P1","P2","P1"],["P2","P1","P1","P2","P1"],["P1","P2","P2","P1"],["P1","P2","P1","P2","P1"],["P1","P1","P2"]],"turn":"P2"}],"id":"3PLGMtvnuwx2XtWjdl82","pass":true,"result":"P1","op":"winner","comment":"P1 win (South-East)","expect":"P1"},{"pass":true,"op":"isValid","result":{"valid":true},"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P2","P1","P2","P1"],["P2","P1","P1","P2","P1"],["P1","P2","P2","P1"],["P1","P2","P1","P2","P1"],["P1","P1","P2"]],"turn":"P2"}],"expect":{"valid":true},"comment":"P1 win is valid (South-East)","id":"wBa7XMsYYhuUE07uxMsj"},{"pass":true,"params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1"],["P2","P1","P2","P1","P2"],["P2","P1","P1","P2","P1"],["P1","P2","P2"],["P1","P2","P1","P2"],["P1","P2","P2"]],"turn":"P1"}],"op":"isValid","comment":"P2 win is valid (South-East)","result":{"valid":true},"expect":{"valid":true},"id":"pcVytVFoXLDk5eQDoaXy"},{"result":{"valid":true},"params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1"],["P2","P1","P2","P1"],["P2","P1","P1","P1","P1"],["P1","P2","P2"],["P1","P2","P1","P2","P2"],["P1","P2","P2","P2"]],"turn":"P2"}],"pass":true,"id":"tGMb50UQ2JRMiXRnZOgr","comment":"P1 win is valid (Vertical)","op":"isValid","expect":{"valid":true}},{"id":"9yWW3X0eQ1MagqBZ0Kwj","pass":true,"comment":"P1 win (Vertical)","params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1"],["P2","P1","P2","P1"],["P2","P1","P1","P1","P1"],["P1","P2","P2"],["P1","P2","P1","P2","P2"],["P1","P2","P2","P2"]],"turn":"P2"}],"op":"winner","expect":"P1","result":{"valid":true}},{"comment":"P2 win is valid (Vertical)","op":"isValid","pass":true,"id":"s9tb4tbHC18IMnq8Qv1F","result":"P1","params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1","P1"],["P2","P1","P2","P1"],["P2","P1","P1","P1"],["P1","P2","P2"],["P1","P2","P1","P2","P2"],["P1","P2","P2","P2","P2"]],"turn":"P1"}],"expect":{"valid":true}},{"comment":"P2 win (Vertical)","id":"Vm2yyQtmdHg5XhKkrIo8","result":{"valid":true},"pass":true,"params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1","P1"],["P2","P1","P2","P1"],["P2","P1","P1","P1"],["P1","P2","P2"],["P1","P2","P1","P2","P2"],["P1","P2","P2","P2","P2"]],"turn":"P1"}],"expect":"P2","op":"winner"},{"comment":"P2 win (South-East)","pass":true,"op":"winner","id":"2EozqANDNIsWdZt0rx84","params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1"],["P2","P1","P2","P1","P2"],["P2","P1","P1","P2","P1"],["P1","P2","P2"],["P1","P2","P1","P2"],["P1","P2","P2"]],"turn":"P1"}],"result":{"valid":true},"expect":"P2"}]},{"label":"Tests centrés sur play","LtestIds":["b4kZF25jBSAuBzFN2qXJ","qcfoC7J2Xuyco68urGt5","R2CYLCliEJ6NMzhwinXP","yChU1qBNQNgh6JQ6WvWH","iCqK3kWJzOMsJ2sc8T9h","Q27G8Ha2dR9bYTvUoL6M","ID1QEDyJelNSuQX31wsq","wrhW8AJ3bqGfIBraGO7E","wyjsQEs96yujowPxSvyK","phjLRjzsSpDMaFN9TPxm","QAU8unGFzPlAePNGcj7B","9Y6TAKJm1vlKbkfN5TcA","THzFebM3mnvxc8eWE62A","7sPqLgqlM5YuZmpT8o54"],"id":"vLSmQjtYL408m9TPGq5G","tests":[{"comment":"second coup sur 4","expect":{"success":true,"state":{"grid":[["P1"],["P2"],[],["P1"],[],[],[]],"turn":"P2"}},"params":[{"grid":[["P1"],["P2"],[],[],[],[],[]],"turn":"P1"},4],"id":"b4kZF25jBSAuBzFN2qXJ","op":"play"},{"id":"qcfoC7J2Xuyco68urGt5","expect":{"state":{"grid":[["P1"],[],[],[],[],[],[]],"turn":"P2"},"success":true},"comment":"play at 1","params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"},1],"op":"play"},{"id":"R2CYLCliEJ6NMzhwinXP","expect":{"success":false,"reason":"no such column"},"comment":"impossible to play at 2.1","op":"play","params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"},2.1]},{"params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"},0],"id":"yChU1qBNQNgh6JQ6WvWH","expect":{"success":false,"reason":"no such column"},"comment":"impossible to play at 0","op":"play"},{"params":[{"grid":[["P1"],["P1"],["P2","P2","P1"],["P1"],["P2","P2"],["P1"],["P2","P1"]],"turn":"P2"},7],"comment":"possible to play at 7","op":"play","expect":{"state":{"grid":[["P1"],["P1"],["P2","P2","P1"],["P1"],["P2","P2"],["P1"],["P2","P1","P2"]],"turn":"P1"},"success":true},"id":"iCqK3kWJzOMsJ2sc8T9h"},{"comment":"Impossible to play at 8","expect":{"success":false,"reason":"no such column"},"params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"},8],"id":"Q27G8Ha2dR9bYTvUoL6M","op":"play"},{"id":"ID1QEDyJelNSuQX31wsq","pass":true,"op":"isValid","comment":"Full grid is valid","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"}],"expect":{"valid":true},"result":{"success":false,"reason":"no such column"}},{"expect":"DRAW","comment":"Draw with full grid and player 1 turn","result":{"valid":true},"op":"winner","pass":true,"id":"wrhW8AJ3bqGfIBraGO7E","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"}]},{"comment":"Draw grid, cannot play at 1","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},1],"pass":true,"result":"DRAW","op":"play","expect":{"success":false,"reason":"column is full"},"id":"wyjsQEs96yujowPxSvyK"},{"op":"play","id":"phjLRjzsSpDMaFN9TPxm","comment":"Draw grid, cannot play at 2","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},2],"pass":true,"expect":{"reason":"column is full","success":false},"result":{"reason":"column is full","success":false}},{"expect":{"success":false,"reason":"column is full"},"op":"play","result":{"reason":"column is full","success":false},"comment":"Draw grid, cannot play at 3","id":"QAU8unGFzPlAePNGcj7B","pass":true,"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},3]},{"comment":"Draw grid, cannot play at 5","pass":true,"id":"9Y6TAKJm1vlKbkfN5TcA","result":{"reason":"column is full","success":false},"expect":{"reason":"column is full","success":false},"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},5],"op":"play"},{"comment":"Draw grid, cannot play at 6","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},6],"pass":true,"id":"THzFebM3mnvxc8eWE62A","op":"play","expect":{"reason":"column is full","success":false},"result":{"success":false,"reason":"column is full"}},{"comment":"Draw grid, cannot play at 7","id":"7sPqLgqlM5YuZmpT8o54","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},7],"pass":true,"expect":{"reason":"column is full","success":false},"op":"play","result":{"success":false,"reason":"column is full"}}]}],"canObserveString":"[   \"alexandre.demeure@univ-grenoble-alpes.fr\", \"sybille.caffiau@univ-grenoble-alpes.fr\", \"Adil-Massa.Adomo-Bitea@etu.univ-grenoble-alpes.fr\", \"Elhadj.Bah@etu.univ-grenoble-alpes.fr\", \"Ibrahima.Barry2@etu.univ-grenoble-alpes.fr\", \"Mariama.Barry@etu.univ-grenoble-alpes.fr\", \"Anas.Benabbou@etu.univ-grenoble-alpes.fr\", \"Ilian.Benaissa@etu.univ-grenoble-alpes.fr\", \"Sami.Bensaid@etu.univ-grenoble-alpes.fr\", \"Mustapha-Mahrez.Bouchelouche@etu.univ-grenoble-alpes.fr\", \"Walid.Bouhali@etu.univ-grenoble-alpes.fr\", \"Leo.Bouvier1@etu.univ-grenoble-alpes.fr\", \"Quentin.Bebin@etu.univ-grenoble-alpes.fr\", \"Kyllian.Charre@etu.univ-grenoble-alpes.fr\", \"Vincent.Chazeau@etu.univ-grenoble-alpes.fr\", \"Seynabou.Conde@etu.univ-grenoble-alpes.fr\", \"Levi.Cormier@etu.univ-grenoble-alpes.fr\", \"Samuel.Damessi@etu.univ-grenoble-alpes.fr\", \"Alex.Delagrange@etu.univ-grenoble-alpes.fr\", \"Oumou.Dembele@etu.univ-grenoble-alpes.fr\", \"Fatoumata.Diaby@etu.univ-grenoble-alpes.fr\", \"Aminata.Diagne@etu.univ-grenoble-alpes.fr\", \"Thierno.Diallo3@etu.univ-grenoble-alpes.fr\", \"Tien.Duong@etu.univ-grenoble-alpes.fr\", \"Anas.El-Bouchrifi@etu.univ-grenoble-alpes.fr\", \"Mouad.El-Kbabty@etu.univ-grenoble-alpes.fr\", \"Chaymae.Elkhou@etu.univ-grenoble-alpes.fr\", \"Khalil.Essouaid@etu.univ-grenoble-alpes.fr\", \"Abdelkader.Ezarouali@etu.univ-grenoble-alpes.fr\", \"Matias.Freund-Galeano@etu.univ-grenoble-alpes.fr\", \"Lucas.Giry@etu.univ-grenoble-alpes.fr\", \"Quentin.Grange@etu.univ-grenoble-alpes.fr\", \"Rayane.Guendouz@etu.univ-grenoble-alpes.fr\", \"Paul.Gueripel@etu.univ-grenoble-alpes.fr\", \"Jocelin.Heinen@etu.univ-grenoble-alpes.fr\", \"Floriane.Jandot@etu.univ-grenoble-alpes.fr\", \"Myriam.Khaddar@etu.univ-grenoble-alpes.fr\", \"Ibrahim-Goukouni.Khalil@etu.univ-grenoble-alpes.fr\", \"Zeinabou.Kone@etu.univ-grenoble-alpes.fr\", \"Hatim.Laghrissi@etu.univ-grenoble-alpes.fr\", \"Yasmine.Larbi@etu.univ-grenoble-alpes.fr\", \"Nour.Machmachi@etu.univ-grenoble-alpes.fr\", \"Salaheddin.Mesouak@etu.univ-grenoble-alpes.fr\", \"Souleymen.Ouchane@etu.univ-grenoble-alpes.fr\", \"Lyna.Oulahcene@etu.univ-grenoble-alpes.fr\", \"Willem.Papeau@etu.univ-grenoble-alpes.fr\", \"Theo.Patrac@etu.univ-grenoble-alpes.fr\", \"Timoty.Razafindrabe@etu.univ-grenoble-alpes.fr\", \"Bastien.Riado@etu.univ-grenoble-alpes.fr\", \"Ayman.Salouh@etu.univ-grenoble-alpes.fr\", \"Floreal.Sangenis@etu.univ-grenoble-alpes.fr\", \"Farah.Seifeddine@etu.univ-grenoble-alpes.fr\", \"Mariam.Sidibe@etu.univ-grenoble-alpes.fr\", \"Damien.Tornambe@etu.univ-grenoble-alpes.fr\", \"Julien.Turc@etu.univ-grenoble-alpes.fr\", \"Marie.Wyss@etu.univ-grenoble-alpes.fr\", \"Sicong.Xu@etu.univ-grenoble-alpes.fr\", \"Mohamad-Majd.Yagan@etu.univ-grenoble-alpes.fr\", \"Kokouvi.Zodjihoue@etu.univ-grenoble-alpes.fr\" ]","canObserve":"[   \"alexandre.demeure@univ-grenoble-alpes.fr\", \"sybille.caffiau@univ-grenoble-alpes.fr\", \"Adil-Massa.Adomo-Bitea@etu.univ-grenoble-alpes.fr\", \"Elhadj.Bah@etu.univ-grenoble-alpes.fr\", \"Ibrahima.Barry2@etu.univ-grenoble-alpes.fr\", \"Mariama.Barry@etu.univ-grenoble-alpes.fr\", \"Anas.Benabbou@etu.univ-grenoble-alpes.fr\", \"Ilian.Benaissa@etu.univ-grenoble-alpes.fr\", \"Sami.Bensaid@etu.univ-grenoble-alpes.fr\", \"Mustapha-Mahrez.Bouchelouche@etu.univ-grenoble-alpes.fr\", \"Walid.Bouhali@etu.univ-grenoble-alpes.fr\", \"Leo.Bouvier1@etu.univ-grenoble-alpes.fr\", \"Quentin.Bebin@etu.univ-grenoble-alpes.fr\", \"Kyllian.Charre@etu.univ-grenoble-alpes.fr\", \"Vincent.Chazeau@etu.univ-grenoble-alpes.fr\", \"Seynabou.Conde@etu.univ-grenoble-alpes.fr\", \"Levi.Cormier@etu.univ-grenoble-alpes.fr\", \"Samuel.Damessi@etu.univ-grenoble-alpes.fr\", \"Alex.Delagrange@etu.univ-grenoble-alpes.fr\", \"Oumou.Dembele@etu.univ-grenoble-alpes.fr\", \"Fatoumata.Diaby@etu.univ-grenoble-alpes.fr\", \"Aminata.Diagne@etu.univ-grenoble-alpes.fr\", \"Thierno.Diallo3@etu.univ-grenoble-alpes.fr\", \"Tien.Duong@etu.univ-grenoble-alpes.fr\", \"Anas.El-Bouchrifi@etu.univ-grenoble-alpes.fr\", \"Mouad.El-Kbabty@etu.univ-grenoble-alpes.fr\", \"Chaymae.Elkhou@etu.univ-grenoble-alpes.fr\", \"Khalil.Essouaid@etu.univ-grenoble-alpes.fr\", \"Abdelkader.Ezarouali@etu.univ-grenoble-alpes.fr\", \"Matias.Freund-Galeano@etu.univ-grenoble-alpes.fr\", \"Lucas.Giry@etu.univ-grenoble-alpes.fr\", \"Quentin.Grange@etu.univ-grenoble-alpes.fr\", \"Rayane.Guendouz@etu.univ-grenoble-alpes.fr\", \"Paul.Gueripel@etu.univ-grenoble-alpes.fr\", \"Jocelin.Heinen@etu.univ-grenoble-alpes.fr\", \"Floriane.Jandot@etu.univ-grenoble-alpes.fr\", \"Myriam.Khaddar@etu.univ-grenoble-alpes.fr\", \"Ibrahim-Goukouni.Khalil@etu.univ-grenoble-alpes.fr\", \"Zeinabou.Kone@etu.univ-grenoble-alpes.fr\", \"Hatim.Laghrissi@etu.univ-grenoble-alpes.fr\", \"Yasmine.Larbi@etu.univ-grenoble-alpes.fr\", \"Nour.Machmachi@etu.univ-grenoble-alpes.fr\", \"Salaheddin.Mesouak@etu.univ-grenoble-alpes.fr\", \"Souleymen.Ouchane@etu.univ-grenoble-alpes.fr\", \"Lyna.Oulahcene@etu.univ-grenoble-alpes.fr\", \"Willem.Papeau@etu.univ-grenoble-alpes.fr\", \"Theo.Patrac@etu.univ-grenoble-alpes.fr\", \"Timoty.Razafindrabe@etu.univ-grenoble-alpes.fr\", \"Bastien.Riado@etu.univ-grenoble-alpes.fr\", \"Ayman.Salouh@etu.univ-grenoble-alpes.fr\", \"Floreal.Sangenis@etu.univ-grenoble-alpes.fr\", \"Farah.Seifeddine@etu.univ-grenoble-alpes.fr\", \"Mariam.Sidibe@etu.univ-grenoble-alpes.fr\", \"Damien.Tornambe@etu.univ-grenoble-alpes.fr\", \"Julien.Turc@etu.univ-grenoble-alpes.fr\", \"Marie.Wyss@etu.univ-grenoble-alpes.fr\", \"Sicong.Xu@etu.univ-grenoble-alpes.fr\", \"Mohamad-Majd.Yagan@etu.univ-grenoble-alpes.fr\", \"Kokouvi.Zodjihoue@etu.univ-grenoble-alpes.fr\" ]","evals":[63,{"play":[12,12],"winner":[11,11],"isValid":[30,30]},{"play":[9,9],"isValid":[14,14],"winner":[7,7]}]}